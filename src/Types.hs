{-# LANGUAGE TypeSynonymInstances #-}
module Types where

import Control.Arrow
import Control.Monad (foldM)
import Data.Maybe ( fromMaybe )
import qualified Data.Map as Map
import qualified Data.Set as Set
import Data.Unique
import Syntax
import Text.PrettyPrint.HughesPJ ( text, (<>),  Doc, render, parens, hcat,
                                   --braces,
                                   punctuate, comma )

---------------------------------------
-------------------------------------
-----------------------------------
---------------------------------
-- Definitions
---------------------------------
-----------------------------------
-------------------------------------
---------------------------------------

--------------------------------------------------------------------------------
-- Type Schemas
--------------------------------------------------------------------------------
data TypeSchema = TS Gammas Constraints Type

type Gammas = Set.Set Gamma
data Gamma =  TG Alpha
            | SG Psi
            | BG Beta
            | RG Rho                  deriving (Eq, Ord)

--------------------------------------------------------------------------------
-- Types
--------------------------------------------------------------------------------
data Type =  TV         Alpha      -- type variable
           | TUnit
           | TBool
           | TInt
           | TPair      Type  Type
--           | TFun       Type  Type
           | TBFun      Type  Type Beta  -- function type with behaviour annot.
--           | TChan      Unique           -- public channel with ses. annotation
           | TSes       Reg              -- open session with region annotation
  deriving ( Eq, Ord )

--------------------------------------------------------------------------------
-- Session Types
--------------------------------------------------------------------------------
data Ses = SV         Psi              -- session variable
         | EVar       Psi              -- ext. choice variable <inference only>
         | IVar       Psi              -- int. choice variable <inference only>
         | SEnd
         | SSend      Type Ses          -- send a type
         | SRecv      Type Ses          -- receive a type
         | SDeleg     Ses  Ses          -- delegate a session
         | SResume    Ses  Ses          -- delegate a session
         | SInC       [(Label, Ses)]    -- internal choice
         | SExC                         -- external choice
                      [(Label, Ses)]      -- active labels
                      [(Label, Ses)]      -- inactive labels
                                        deriving (Eq, Ord)

--------------------------------------------------------------------------------
-- Behaviours
--------------------------------------------------------------------------------
data Behav =  BV      Beta
            | BTau
            | BPush   R       Ses
            | BOp     BOps
            | BSeq    Behav   Behav
            | BRec    Behav   Beta
            | BSpawn  Behav
            | BIn     Behav   Behav
            | BEx     Reg [(Label, Behav)]  deriving ( Eq, Ord )

-- Pop Actions
data BOps = BSend     Reg Type
          | BRecv     Reg Type
          | BDeleg    Reg Reg
          | BResume   Reg Reg
          | BInC      Reg Label            deriving (Eq, Ord)

---------------------------------------------
---- Regions
---------------------------------------------
-- see Syntax.hs



-------------------------------------------
-- Typing Context
-------------------------------------------
type TypingContext = [TCItem]

data TCItem = TSVar Name TypeSchema
            | TyVar Name Type



-------------------------------------------
-- (Atomic) constraints
-------------------------------------------
data SesLab = SReq Name R
            | SAcc Name R   deriving ( Ord )
instance Eq SesLab where
  (==) (SReq c1 _) (SReq c2 _) = c1 == c2
  (==) (SAcc c1 _) (SAcc c2 _) = c1 == c2
  (==) _ _                     = False

type LabelMap = Map.Map Label Ses


data Constraint = TC Type   Type          -- type constraints
{- The previous definition of session constraint was the following:
      SC Ses    Psi
  where Ses is a session \eta, and Psi is a session variable \psi, defined
  as follows:

  data Psi   = Psi    Unique
           | VarPsi Unique
           | BarPsi Unique

  where VarPsi is the annotation attached to channels before starting type
  inference, and BarPsi is the dual annotation generated by Accept during type
  inference.

  The problem with this definition is that session variables have a double
  function: they work as variables in type schemas, but they also work as
  labels that connect a unique channel c with a session type.

  During Algorithm R, constraints are simplified and possibly removed;
  variables are renamed accordingly. In the case of sessions, constraints
  on session labels must be treated carefully. For example, a session constraint
  (SC psi1 psi2)  might be removed by the Shrink rule, which generates the
  substitution [psi2 -> psi1]. We do not want to lose information in this way.

  Therefore, it is better to separate the use of session variables and session
  labels in two distinct constructs, and to use session variables for type
  schemas, and session labels for constraints and the channel type.

-}
                | SC    Ses                 SesLab      -- session constraints
                | BC    Behav               Beta        -- behaviour constraints
                | RC    Reg                 Rho         -- region constraints
                | DC    Ses                 Ses         -- duality constraints
                -- these constraints are only used for inference purposes
                | IVarC LabelMap Psi                    -- internal choice
                | EVarC LabelMap LabelMap Psi           -- external choice
  deriving ( Eq, Ord )


type Constraints = Set.Set Constraint









---------------------------------------
-------------------------------------
-----------------------------------
---------------------------------
-- Gamma Substitution
---------------------------------
-----------------------------------
-------------------------------------
---------------------------------------
{- A substitution "Sub" maps session, behaviour and region variables to
  variables of the same kind; it maps type variables to types (either variables
  or concrete types). -}
data Substitution = Sub {
  tsub :: TSub,               -- types
  ssub :: SSub,               -- sessions
  bsub :: BSub,               -- behaviours
  rsub :: RSub,                -- regions
  slsub :: SLSub
}

type TSub = Map.Map Unique Type
type SSub = Map.Map Unique Ses
type BSub = Map.Map Unique Unique
type RSub = Map.Map Unique Unique
type SLSub = Map.Map Unique Unique

-- free variables
data FreeVars = FreeVars {
  tvars  :: Set.Set Unique,
  svars  :: Set.Set Unique,
  bvars  :: Set.Set Unique,
  rvars  :: Set.Set Unique}



-- Instances of Substitutable can apply a gamma variable substitution on
-- themselves, and return the set of free gamma variables they contain.
class Substitutable a where
  apply    :: Substitution -> a -> a
  freevars :: a -> FreeVars




instance Substitutable Gamma where
  apply sigma (TG t) = TG (apply sigma t )
  apply sigma (SG s) = SG (apply sigma s)
  apply sigma (RG r) = RG (apply sigma r)
  apply sigma (BG b) = BG (apply sigma b)

  freevars (TG t) = freevars t
  freevars (SG s) = freevars s
  freevars (RG r) = freevars r
  freevars (BG b) = freevars b

instance Substitutable Gammas where
  apply sigma = Set.map (apply sigma)
  freevars gs = foldr (unionFV . freevars) emptyFreeVars (Set.toList gs)



-- Variables
instance Substitutable Alpha where
  apply    _        i  = error $ "Trying to substitute type variable " ++ show i
  freevars (Alpha i)    = mkTFV [i]

instance Substitutable Psi where
  apply sigma (Psi i)  = case Map.lookup i ( ssub sigma ) of
    Nothing           -> Psi i
    Just (SV (Psi j))    -> Psi j
--    Just (SV (VarPsi j)) -> VarPsi j
--    Just (SV (BarPsi j)) -> BarPsi j
    Just _               -> error "Trying to substitute session variable "
--                                    ++ show (Psi i)
--                                    ++ " with "
--                                    ++ show x

--  apply _ (VarPsi i)  = VarPsi i
--        case Map.lookup i ( ssub sigma ) of
--    Nothing           -> VarPsi i
--    Just (SV (Psi j))    -> Psi j
--    Just (SV (VarPsi j)) -> VarPsi j
--    Just (SV (BarPsi j)) -> BarPsi j
--    Just _               -> VarPsi i
--    error $ "Trying to substitute session variable "
--                                    ++ show (Psi i)
--                                    ++ " with "
--                                    ++ show x

--  apply _ (BarPsi i)  = BarPsi i
--    case Map.lookup i ( ssub sigma ) of
--    Nothing           -> BarPsi i
--    Just (SV (Psi j))    -> Psi j
--    Just (SV (VarPsi j)) -> VarPsi j
--    Just (SV (BarPsi j)) -> BarPsi j
--    Just _               -> BarPsi i
--    error $ "Trying to substitute session variable "
--                                    ++ show (Psi i)
--                                    ++ " with "
--                                    ++ show x
--  apply    _        i  = i -- error $ "Trying to substitute non-variable " ++ show i

--  apply s (Psi i)    = SV $ Psi    ( fromMaybe i ( Map.lookup i ( ssub s ) ) )
--  apply s (VarPsi i) = SV $ VarPsi ( fromMaybe i ( Map.lookup i ( ssub s ) ) )
--  apply s (BarPsi i) = SV $ BarPsi ( fromMaybe i ( Map.lookup i ( ssub s ) ) )

  freevars (Psi i)    = mkSFV [i]
--  freevars (VarPsi i) = mkSFV [i]
--  freevars (BarPsi i) = mkSFV [i]


instance Substitutable Beta where
  apply    s  (Beta i) = Beta ( fromMaybe i ( Map.lookup i ( bsub s ) ) )
  freevars (Beta i)    = mkBFV [i]

instance Substitutable Rho where
  apply    s  (Rho i) = Rho ( fromMaybe i ( Map.lookup i ( rsub s ) ) )
  freevars (Rho i)    = mkKFV [i]


-- Types
instance Substitutable Type where
  apply s t = case t of
    TV (Alpha i) -> fromMaybe t ( Map.lookup i ( tsub s ) )
    TUnit        -> TUnit
    TBool        -> TBool
    TInt         -> TInt
    --
    TPair t1 t2   -> TPair (apply s t1) (apply s t2)
--    TFun t1 t2    -> TFun  (apply s t1) (apply s t2)
    TBFun t1 t2 b -> TBFun (apply s t1) (apply s t2) (apply s b)
    --
--    TChan l -> TChan l
    TSes r    -> TSes (apply s r)

  freevars t = case t of
    TV (Alpha i) -> mkTFV [i]
    TUnit        -> emptyFreeVars
    TBool        -> emptyFreeVars
    TInt         -> emptyFreeVars
    --
    TPair t1 t2   -> freevars t1 `unionFV` freevars t2
--    TFun  t1 t2   -> freevars t1 `unionFV` freevars t2
    TBFun t1 t2 b -> freevars t1 `unionFV` freevars t2 `unionFV` freevars b
    --
--    TChan _  -> emptyFreeVars -- TODO: check
    TSes r   -> freevars r

-- Sessions
instance Substitutable  Ses where
  apply sigma s = case s of
    SV (Psi i)     -> fromMaybe s ( Map.lookup i ( ssub sigma ) )
    EVar (Psi i)   -> fromMaybe s ( Map.lookup i ( ssub sigma ) )
    IVar (Psi i)   -> fromMaybe s ( Map.lookup i ( ssub sigma ) )
--    SV (VarPsi i)  -> fromMaybe s ( Map.lookup i ( ssub sigma ) )
--    SV (BarPsi i)  -> fromMaybe s ( Map.lookup i ( ssub sigma ) )

    --SV (apply sigma sv)
    SEnd   -> SEnd
    --
    SSend t s1 -> SSend (apply sigma t) (f s1)
    SRecv t s1 -> SRecv (apply sigma t) (f s1)
    --
    SDeleg  s1 s2 -> SDeleg  (f s1) (f s2)
    SResume s1 s2 -> SResume (f s1) (f s2)
    --
    SInC ss -> SInC (map (second f) ss)
    SExC as is -> SExC (map (second f) as) (map (second f) is)
   where f = apply sigma


  freevars s = case s of
    SV sv  -> freevars sv
    EVar _ -> emptyFreeVars
    IVar _ -> emptyFreeVars

    SEnd   -> emptyFreeVars
    --
    SSend t s1 -> freevars t `unionFV` freevars s1
    SRecv t s1 -> freevars t `unionFV` freevars s1
    --
    SDeleg  s1 s2 -> freevars s1 `unionFV` freevars s2
    SResume s1 s2 -> freevars s1 `unionFV` freevars s2
    --
    SInC ss -> foldr (unionFV . freevars . snd) emptyFreeVars ss
    SExC as is -> foldr (unionFV . freevars . snd) emptyFreeVars as
                    `unionFV`
                  foldr (unionFV . freevars . snd) emptyFreeVars is


--behaviours
instance Substitutable Behav where
  apply sigma b = case b of
    BV bv -> BV (apply sigma bv)--( Rho ( fromMaybe i ( Map.lookup i ( bsub sigma ) ) ) )
    --
    BTau        -> BTau
    BPush   l s -> BPush l (apply sigma s)
    BOp     pa  -> BOp (apply sigma pa)
    --
    BSeq b1 b2  -> BSeq     (f b1) (f b2)
    BRec b1 b2  -> BRec   (f b1) (case f (BV b2) of
                                    BV b2' -> b2'
                                    _ -> error "unexpected b. var.")
    BSpawn b1     -> BSpawn (f b1)
    BIn b1 b2  -> BIn (f b1) (f b2)
    BEx r  bs  -> BEx (apply sigma r)
                            (map (second f) bs)
   where f = apply sigma

  freevars b = case b of
    BV (Beta i) -> mkBFV [i]
    --
    BTau      -> emptyFreeVars
    BPush _ s -> freevars s
    BOp  pa  -> freevars pa
    --
    BSeq b1 b2  -> freevars b1 `unionFV` freevars b2
    BRec b1 _   -> freevars b1
    BSpawn b1   -> freevars b1
    --
    BIn  b1 b2  -> freevars b1 `unionFV` freevars b2
    BEx r  bs  -> foldr (unionFV . freevars . snd) (freevars r) bs

instance Substitutable BOps where
  apply sigma pa = case pa of
    BSend   r  t  -> BSend   (f r)  (g t)
    BRecv   r  t  -> BRecv   (f r)  (g t)
    BDeleg  r1 r2 -> BDeleg  (f r1) (f r2)
    BResume r1 r2 -> BResume (f r1) (f r2)
    BInC    r  l  -> BInC    (f r)  l
    where f = apply sigma
          g = apply sigma

  freevars pa = case pa of
    BSend   r  t  -> freevars r `unionFV` freevars t
    BRecv   r  t  -> freevars r `unionFV` freevars t
    BDeleg  r1 r2 -> freevars r1 `unionFV` freevars r2
    BResume r1 r2 -> freevars r1 `unionFV` freevars r2
    BInC    r  _  -> freevars r


-- Regions
instance Substitutable Reg where
  apply sigma r = case r of
    RV r1 -> RV ( apply sigma r1 )
    RL _  -> r

  freevars r = case r of
    RV r1 -> freevars r1
    RL _ -> emptyFreeVars


instance Substitutable SLabel where
  apply s (SL i) = SL ( fromMaybe i ( Map.lookup i ( slsub s ) ) )
  freevars _ = emptyFreeVars

instance Substitutable SesLab where
  apply _ (SReq c l) = SReq c l
  apply _ (SAcc c l) = SAcc c l

  freevars _ = emptyFreeVars

-- Constraints
instance Substitutable Constraint where
  apply sigma ( TC t1 t2 )  = TC ( apply sigma t1 ) ( apply sigma t2 )
  apply sigma ( SC s1 s2 )  = SC ( apply sigma s1 ) ( apply sigma s2 )
  apply sigma ( BC b1 b2 )  = BC ( apply sigma b1 ) ( apply sigma b2 )
  apply sigma ( RC r1 r2 )  = RC ( apply sigma r1 ) ( apply sigma r2 )
  apply sigma ( DC s1 s2 )  = DC ( apply sigma s1 ) ( apply sigma s2 )
  apply sigma ( EVarC as is i ) = EVarC ( Map.map (apply sigma) as )
                                        ( Map.map (apply sigma) is )
                                        ( apply sigma i )
  apply sigma ( IVarC cs i ) = IVarC ( Map.map (apply sigma) cs )
                                     ( apply sigma i )

  freevars ( TC t1 t2 ) = freevars t1 `unionFV` freevars t2
  freevars ( SC s1 _)   = freevars s1 --`unionFV` freevars s2
  freevars ( BC b1 b2 ) = freevars b1 `unionFV` freevars b2
  freevars ( RC r1 r2 ) = freevars r1 `unionFV` freevars r2
  freevars ( DC s1 s2 ) = freevars s1 `unionFV` freevars s2
  freevars ( EVarC as is _ ) = foldr (unionFV . freevars )
                                     emptyFreeVars
                                     (Map.elems as ++ Map.elems is)
  freevars ( IVarC cs _ ) = foldr (unionFV . freevars )
                                  emptyFreeVars
                                  (Map.elems cs)

instance Substitutable Constraints where
  apply sigma = Set.map (apply sigma)
  freevars    = Set.fold ( unionFV . freevars ) emptyFreeVars



instance Substitutable TypingContext where
  apply sigma = map (apply sigma)
--  TCtx $ map (\(x,y,z) -> let sigma' = deleteGenVars y sigma
--                                                   in ( apply sigma' x, y, apply sigma' z ) ) ctx
  freevars = foldr (unionFV. freevars) emptyFreeVars



instance Substitutable TCItem where
  apply sigma (TSVar x (TS gs cs t)) = TSVar x (TS gs (f cs) (g t))
    where
      f      = apply sigma'
      g      = apply sigma'
      sigma' = deleteGenVars gs' sigma
      gs'    = freevars gs
      deleteGenVars (FreeVars ts' ss' bs' rs' ) (Sub ts ss bs rs sl ) = let
        ts'' = Set.fold Map.delete ts ts'
        ss'' = Set.fold Map.delete ss ss'
        bs'' = Set.fold Map.delete bs bs'
        rs'' = Set.fold Map.delete rs rs'
        in Sub ts'' ss'' bs'' rs'' sl
  apply sigma (TyVar x t)        = TyVar x (apply sigma t)

  freevars (TSVar _ (TS gs cs t)) = (freevars t `unionFV` freevars cs) `diffFV` freevars gs
  freevars (TyVar _ t)            = freevars t

--  freevars (TCtx ctx) = foldl (\c (t, a, z) -> c `unionFV` ((freevars t `unionFV` freevars z) `diffFV` a)) emptyFreeVars ctx


singletonTCtx :: Type -> (Type, FreeVars, Constraints)
singletonTCtx t = ( t, emptyFreeVars, Set.empty )


---------------------------------------
-------------------------------------
-----------------------------------
---------------------------------
-- Utilities
---------------------------------
-----------------------------------
-------------------------------------
---------------------------------------

fvMember :: Unique -> FreeVars -> Bool
fvMember i ( FreeVars t s b r ) = any (Set.member i) [t, s, b, r]

isEmptyFV :: FreeVars -> Bool
isEmptyFV (FreeVars t s b k ) = all Set.null [t,s,b,k]

prjKappas :: FreeVars -> Set.Set Unique
prjKappas ( FreeVars _ _ _ k ) = k




newAlphaType :: IO Type
newAlphaType = do
  tvar <- newAlpha
  return (TV tvar)

mkGammas :: FreeVars -> Gammas
mkGammas ( FreeVars ts ss bs rs ) = Set.fromList(
  map (TG . Alpha ) (Set.toList ts)
  ++ map (SG . Psi   ) (Set.toList ss)
  ++ map (BG . Beta  ) (Set.toList bs)
  ++ map (RG . Rho ) (Set.toList rs)
  )


unionFV :: FreeVars -> FreeVars -> FreeVars
unionFV ( FreeVars t1 s1 b1 r1 )
        ( FreeVars t2 s2 b2 r2 ) =  FreeVars ( t1  `Set.union` t2 )
                                                 ( s1  `Set.union` s2 )
                                                 ( b1  `Set.union` b2 )
                                                 ( r1  `Set.union` r2 )

diffFV :: FreeVars -> FreeVars -> FreeVars
diffFV ( FreeVars t1 s1 b1 r1 )
       ( FreeVars t2 s2 b2 r2 ) = FreeVars ( t1  `Set.difference` t2 )
                                           ( s1  `Set.difference` s2 )
                                           ( b1  `Set.difference` b2 )
                                           ( r1  `Set.difference` r2 )

intersectionFV :: FreeVars -> FreeVars -> FreeVars
intersectionFV ( FreeVars t1 s1 b1 r1 )
               ( FreeVars t2 s2 b2 r2 ) = FreeVars
                                                ( t1  `Set.intersection` t2 )
                                                ( s1  `Set.intersection` s2 )
                                                ( b1  `Set.intersection` b2 )
                                                ( r1  `Set.intersection` r2 )


emptyFreeVars :: FreeVars
emptyFreeVars = FreeVars e e e e
  where e = Set.empty


mkFV ::[Unique] -> [Unique] -> [Unique] -> [Unique]  -> FreeVars
mkFV ts ss bs rs = FreeVars ( Set.fromList ts )
                            ( Set.fromList ss )
                            ( Set.fromList bs )
                            ( Set.fromList rs )

mkTFV ::[Unique] -> FreeVars
mkTFV ts = FreeVars ( Set.fromList ts ) e e e
  where e = Set.empty

mkSFV ::[Unique] -> FreeVars
mkSFV ss = FreeVars e ( Set.fromList ss ) e e
  where e = Set.empty

mkBFV ::[Unique] -> FreeVars
mkBFV bs = FreeVars e e ( Set.fromList bs ) e
  where e = Set.empty

mkKFV ::[Unique] -> FreeVars
mkKFV rs = FreeVars e e e ( Set.fromList rs )
  where e = Set.empty

toListFV :: FreeVars -> [Unique]
toListFV ( FreeVars ts ss bs rs ) =   Set.toList ts
                                      ++  Set.toList ss
                                      ++  Set.toList bs
                                      ++  Set.toList rs


sizeFV :: FreeVars -> Int
sizeFV ( FreeVars ts ss bs rs ) = Set.size ts
                                + Set.size ss
                                + Set.size bs
                                + Set.size rs











freshInstanceTS :: TypeSchema -> IO (Substitution, Type, Behav, Set.Set Constraint)
freshInstanceTS (TS gs cs t) = do
    let ( FreeVars ts ss bs rs ) = freevars gs
    tsigma <- foldM (\sub oldId  -> do
                        newId <- newUnique
                        return (sub `compose` mkTSub oldId newId) )
                    idSub
                    ( Set.toList ts )
    ssigma <- foldM (\sub oldId  -> do
                        newId <- newUnique
                        return (sub `compose` mkSSub oldId newId) )
                    idSub
                    ( Set.toList ss )
    bsigma <- foldM (\sub oldId  -> do
                        newId <- newUnique
                        return (sub `compose` mkBSub oldId newId) )
                    idSub
                    ( Set.toList bs )
    rsigma <- foldM (\sub oldId  -> do
                        newId <- newUnique
                        return (sub `compose` mkRSub oldId newId) )
                    idSub
                    ( Set.toList rs )
    let sigma = tsigma `compose` ssigma `compose` bsigma `compose` rsigma
        t'    = apply sigma t
        cs'   = apply sigma cs
    cs'' <- mapM return (Set.toList cs')
    let cs''' = Set.fromList cs''
    return (idSub, t',  BTau, cs''' )


idSub :: Substitution
idSub = Sub m m m m m
  where m = Map.empty


mkTSub :: Unique -> Unique -> Substitution
mkTSub i1 i2 = Sub m' m m m m
  where m' = Map.fromList [(i1, TV (Alpha i2))]
        m  = Map.empty


mkSSub :: Unique -> Unique -> Substitution
mkSSub i1 i2 = Sub m m' m m m
  where m' = Map.fromList [(i1, SV (Psi i2))]
        m  = Map.empty

-- maps all session variables to \end
finalize :: FreeVars -> Substitution
finalize fv = Sub m m' m m m
  where
        ss = Set.toList $ svars fv -- session variables
        m' = Map.fromList (map (\s -> (s, SEnd)) ss)
        m  = Map.empty

mkSesSub :: Unique -> Ses -> Substitution
mkSesSub i s = Sub m m' m m m
  where m' = Map.fromList [(i, s)]
        m  = Map.empty

mkBSub :: Unique -> Unique -> Substitution
mkBSub i1 i2 = Sub m m m' m m
  where m' = Map.fromList [(i1, i2)]
        m  = Map.empty


mkRSub :: Unique -> Unique -> Substitution
mkRSub i1 i2 = Sub m m m m' m
  where m' = Map.fromList [(i1, i2)]
        m  = Map.empty

mkSLSub :: Unique -> Unique -> Substitution
mkSLSub i1 i2 = Sub m m m m m'
  where m' = Map.fromList [(i1, i2)]
        m  = Map.empty





compose :: Substitution -> Substitution -> Substitution
compose s1 s2 = Sub ts ss bs rs sls
  where ts = combineType (tsub s1) (tsub s2)
        ss = combineSes  (ssub s1) (ssub s2)
        bs = combine (bsub s1) (bsub s2)
        rs = combine (rsub s1) (rsub s2)
        sls = combine (slsub s1) (slsub s2)
        combine r1 r2 = Map.map  (\a -> fromMaybe a (Map.lookup a r2)) r1
                          `Map.union` Map.difference r2 r1
        combineType t1 t2 = Map.map (apply s2) t1 `Map.union` Map.difference t2 t1
        combineSes ses1 ses2 = Map.map (apply s2) ses1 `Map.union` Map.difference ses2 ses1

--------------------------------------------------------------------------------
-- returns the constraints under which a session is a subtype of another
-- session, together with a substitution in case one of the two sessions
-- contains a session variable
--------------------------------------------------------------------------------
sesSubtype :: Ses -> Ses -> (Substitution, Constraints)
--------------------------------------------------------------------------------
-- sessions are finished
sesSubtype SEnd SEnd        = (idSub, Set.empty)

-- one of the two session is a variable
sesSubtype (SV (Psi i1)) s2 = (mkSesSub i1 s2, Set.empty)
sesSubtype s1 (SV (Psi i2)) = (mkSesSub i2 s1, Set.empty)
--------------------------------------------------------------------------------
-- send data
sesSubtype (SSend t1 s1) (SSend t2 s2) = (sigma, Set.insert c cs)
  where (sigma, cs) = sesSubtype s1 s2
        c           = TC t2 t1

-- recv data
sesSubtype (SRecv t1 s1) (SRecv t2 s2) = (sigma, Set.insert c cs)
  where (sigma, cs) = sesSubtype s1 s2
        c           = TC t1 t2

-- delegation
sesSubtype (SDeleg s_del1 s1) (SDeleg s_del2 s2) = (sigma, cs)
  where (sigma, cs) = let (s',  cs' ) = sesSubtype s_del2 s_del1
                          (s'', cs'') = sesSubtype (apply s' s1) (apply s' s2)
                      in  (compose s' s'', apply s'' cs' `Set.union` cs'')
-- resume
sesSubtype (SResume s_res1 s1) (SResume s_res2 s2) = (sigma, cs)
  where (sigma, cs) = let (s',  cs' ) = sesSubtype s_res1 s_res2
                          (s'', cs'') = sesSubtype (apply s' s1) (apply s' s2)
                      in  (compose s' s'', apply s'' cs' `Set.union` cs'')

-- internal choice
sesSubtype (SInC _) (SInC _) = undefined -- should not be possible
sesSubtype (IVar _) (IVar _) = undefined -- TODO

-- external choice
sesSubtype (SExC _ _) (SExC _ _) = undefined -- should not be possible
sesSubtype (EVar _) (EVar _) = undefined -- TODO

-- in any other case the sessions do not match -- TODO: better error handling
sesSubtype _ _ = error "Session mismatch"













instance Substitutable Val where
  apply s v = case v of
    U       -> v
    TT      -> v
    FF      -> v
    N _     -> v
    --
    PairV v1 v2   -> PairV (apply s v1) (apply s v2)
--    PubChan x l   -> PubChan x l
    Ses     r     -> Ses (apply s r)
    Fun     x e   -> Fun x (apply s e)
    Fix     f x e -> Fix f x (apply s e)

  freevars v = case v of
    U       -> emptyFreeVars
    TT      -> emptyFreeVars
    FF      -> emptyFreeVars
    N _     -> emptyFreeVars
    --
    PairV v1 v2 -> freevars v1 `unionFV` freevars v2
--    PubChan _ _ -> emptyFreeVars
--    case p of
--           -> error "Psi variable not allowed in chan" --mkSFV [psi]
--      (VarPsi psi)  -> emptyFreeVars -- mkSFV [psi]
--      (BarPsi psi)  -> emptyFreeVars -- mkSFV [psi]
    Ses k -> case k of
      RV (Rho chi)  -> mkKFV [chi]
      RL (R lab)    -> mkKFV [lab]
    Fun _ e   -> freevars e
    Fix _ _ e -> freevars e

-- Expressions
instance Substitutable Exp where
  apply s e = case e of
    V v -> V (apply s v)
    --
    Free  _   -> e
    Bound _ _ -> e
    Pair e1 e2  -> Pair (apply s e1) (apply s e2)
    App  e1 e2  -> App  (apply s e1) (apply s e2)
    --
    Let  x  e1 e2 -> Let x (apply s e1) (apply s e2)
    If   e1 e2 e3 -> If    (apply s e1) (apply s e2) (apply s e3)
    --
    C _  -> e
    Select e' l  -> Select (apply s e') l
    Match  e' es -> Match (apply s e') (map (second (apply s)) es)
    Spawn  e'    -> Spawn (apply s e')
    Req c l       -> Req c l
    Acc c l       -> Acc c l

  freevars e = case e of
    V v -> freevars v
    --
    Free  _   -> emptyFreeVars
    Bound _ _ -> emptyFreeVars
    Pair e1 e2  -> freevars e1 `unionFV` freevars e2
    App  e1 e2  -> freevars e1 `unionFV` freevars e2
    --
    Let  _  e1 e2 -> freevars e1 `unionFV` freevars e2
    If   e1 e2 e3 -> freevars e1 `unionFV` freevars e2 `unionFV` freevars e3
    --
    C   _ -> emptyFreeVars
--        c  ->  case c of
--      Request (R k) -> mkKFV [k]
--      Accept  (R k) -> mkKFV [k]
--      Resume  (R k) -> mkKFV [k]
--      Send  -> emptyFreeVars
--      Recv  -> emptyFreeVars
--      Delegate -> emptyFreeVars
    Select e' _  -> freevars e'
    Match  e' es -> foldr (unionFV . freevars . snd) (freevars e') es
    Spawn  e'    -> freevars e'
    Req _ _      -> emptyFreeVars
    Acc _ _      -> emptyFreeVars





















--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
-- Pretty Printing
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
instance Show SesLab where show = render . ppSesLab

ppSesLab :: SesLab -> Doc
ppSesLab (SReq c l) = text ("{" ++ c ++ "}^{") <> ppRL l <> text "}"
ppSesLab (SAcc c l) = text ("\\overline{{" ++ c ++ "}^{") <> ppRL l <> text "}}"



-- Variables
ppTSub :: TSub -> Doc
ppTSub s =  text "[ "
            <> hcat
                (punctuate
                  (text ", ")
                  (map
                    (\(x,y) -> ppAlpha (Alpha x) <> text "\\mapsto" <> ppType y )
                    (Map.toList s)))
            <> text "]"

ppSSub :: SSub -> Doc
ppSSub s =  text "["
            <> hcat
                (punctuate
                  (text ", ")
                  (map
                    (\(x,y) -> ppPsi (Psi x) <> text "\\mapsto" <> ppSession y)
                    (Map.toList s)))
            <> text "]"

ppBSub :: BSub -> Doc
ppBSub s =  text "["
            <> hcat
                (punctuate
                  (text ", ")
                  (map
                    (\(x,y) -> ppBeta (Beta x) <> text "\\mapsto" <> ppBeta (Beta y))
                    (Map.toList s)))
            <> text "]"

ppRSub :: RSub -> Doc
ppRSub s =  text "["
            <> hcat
                (punctuate
                  (text ", ")
                  (map
                    (\(x,y) -> ppRho (Rho x) <> text "\\mapsto" <> ppRho (Rho y))
                    (Map.toList s)))
            <> text "]"


ppSLSub :: SLSub -> Doc
ppSLSub s =  text "["
            <> hcat
                (punctuate
                  (text ", ")
                  (map
                    (\(x,y) -> ppSLabel (SL x) <> text "\\mapsto "
                               <> ppSLabel (SL y))
                    (Map.toList s)))
            <> text "]"


-- Substitutables

instance Show Substitution where show = render . ppSub
ppSub :: Substitution -> Doc
ppSub ( Sub ts ss bs rs sls) = text " $ "
                            <> hcat
                              ( punctuate
                                ( text " " )
                                [ppT, ppS, ppB, ppR, ppSL] )
                            <> text " $ "
  where ppT = ppTSub ts
        ppS = ppSSub ss
        ppB = ppBSub bs
        ppR = ppRSub rs
        ppSL = ppSLSub sls



instance Show FreeVars where show = render . ppFV
ppFV :: FreeVars -> Doc
ppFV ( FreeVars ts ss bs rs ) = text "FV: " <> tv <> sc <>bv <> rv
  where tv = if Set.null ts
              then text ""
              else text "Type: ["
                   <> hcat ( punctuate ( text ", ")
                                       ( map (ppAlpha . Alpha )
                                             ( Set.toList ts ) ) )
                   <> text "] "
        sc = if Set.null ss
              then text ""
              else text "Ses: ["
                   <> hcat ( punctuate ( text ", ")
                                       ( map (ppPsi . Psi )
                                             ( Set.toList ts ) ) )
                   <> text "] "
        bv = if Set.null bs
              then text ""
              else text "Beh: ["
                   <> hcat ( punctuate ( text ", ")
                                       ( map (ppBeta . Beta )
                                             ( Set.toList ts ) ) )
                   <> text "] "
        rv = if Set.null rs
              then text ""
              else text "Reg: ["
                   <> hcat ( punctuate ( text ", ")
                                       ( map (ppRho . Rho )
                                             ( Set.toList ts ) ) )
                   <> text "] "


-- Type Schemas
instance Show TypeSchema where show = render . ppTS
ppTS :: TypeSchema -> Doc
ppTS (TS gs cs t) = text "\\forall ("
                  <> hcat gammas
                  <> text " : "
                  <> hcat constraints
                  <> text "). "
                  <> ppType t
 where
  gammas      = punctuate (comma <> text " ") (map ppGamma (Set.toList gs))
  constraints = punctuate (comma <> text " ") (map ppConstraint (Set.toList cs))


instance Show Gamma where show = render . ppGamma
ppGamma :: Gamma -> Doc
ppGamma g = case g of
  TG t -> ppAlpha t
  SG s -> ppPsi s
  RG t -> ppRho t
  BG b -> ppBeta b





-- Types
instance Show Type where show = render . ppType
ppType :: Type -> Doc
ppType t = case t of
  TV    tvar -> ppAlpha tvar
  TUnit      -> text "\\tunit"
  TBool      -> text "\\tbool"
  TInt       -> text "\\tint"
  --
  TPair    t1 t2    -> parens ( ppType t1 <> text " \\times " <> ppType t2 )
--  TFun     t1 t2    -> ppType t1 <> text " \\rightarrow " <> ppType t2
  TBFun    t1 t2 b  -> ppType t1 <> text " \\xrightarrow{"
                       <> ppBeta b <> text "} "
                       <> ppType t2
  --
--  TChan sl  -> text "\\tchan{ " <> ppSLabel sl <> text "}{}"
  TSes  r   -> text " \\tses{ " <> ppReg r <> text "}"


-- Sessions
instance Show Ses where show = render . ppSession
ppSession :: Ses -> Doc
ppSession s = case s of
  SV     psi -> ppPsi psi
  EVar (Psi i) -> text "\\psiext_{" <> ppUnique i <> text "}"
  IVar (Psi i) -> text "\\psiint_{" <> ppUnique i <> text "}"
  --
  SEnd       -> text "\\tend"
  --
  SSend  t s1     -> text "!" <> ppType t <> text "." <> ppSession s1
  SRecv  t s1     -> text "?" <> ppType t <> text "." <> ppSession s1
  --
  SDeleg   s1 s2  -> text "![" <> ppSession s1 <> text "]." <> ppSession s2
  SResume  s1 s2  -> text "?[" <> ppSession s1 <> text "]." <> ppSession s2
  --
  SInC     ss     -> hcat (punctuate
                          (comma <> text " (+) " )
                          (map
                            (\(l_i, s_i) -> text "!"
                                            <> text (l_i ++ ".")
                                            <> ppSession s_i )
                            ss))
  SExC    as is   ->  text " +{ "
                      <> hcat (punctuate
                                (text ", " )
                                (map
                                  (\(l_i, s_i) -> text "?_{Ac} "
                                                <> text (l_i ++ ".")
                                                <> ppSession s_i )
                                  as))
                      <> text " -- "
                      <> hcat (punctuate
                                (text ", " )
                                (map
                                  (\(l_i, s_i) -> text "?_{In} "
                                                  <> text (l_i ++ ".")
                                                  <> ppSession s_i )
                                  is)
                                  )
                      <> text "}"


-- behaviours
instance Show Behav where show = render . ppBehav
ppBehav :: Behav -> Doc
ppBehav b = case b of
  BV      bvar  -> ppBeta bvar
  BTau          -> text "\\tau"
  BSeq    b1 b2 -> ppBehav b1 <> text "; " <> ppBehav b2
  BRec    b1 b2 -> text "\\orec{ " <> parens (ppBehav b1)   <> text "}{"
                   <> ppBeta b2 <> text "}"
  BSpawn  b1    -> text "\\espawn{ " <> parens (ppBehav b1) <> text "}"
  BIn  b1 b2 -> parens (ppBehav b1 <> text " \\oplus " <> ppBehav b2)
  BPush   l  s  -> text "\\pusho{ " <> ppRL l
                   <> text "} {"    <> ppSession s  <> text "}{}"
  BOp    p     -> ppPopAct p
  BEx  r cs  -> text "+ \\{" <>  hcat (punctuate
                          (text ",~" )
                          (map
                            (\(l_i, b_i) -> ppReg r
                                              <> text "?"
                                              <> text (l_i ++ ".")
                                              <> ppBehav b_i )
                            cs)) <> text " \\}"

-- pop actions
instance Show BOps where show = render . ppPopAct
ppPopAct :: BOps -> Doc
ppPopAct pa = case pa of
  BSend   k t   -> ppReg k  <> text "!" <> ppType t
  BRecv   k t   -> ppReg k  <> text "?" <> ppType t
  BDeleg  k1 k2 -> ppReg k1 <> text "!" <> ppReg k2
  BResume k1 k2 -> ppReg k1 <> text "?" <> ppReg k2
  BInC    k l   -> ppReg k  <> text ('!' : l)

-- constraints
instance Show Constraint where show = render . ppConstraint
ppConstraint :: Constraint -> Doc
ppConstraint c = case c of
  TC t1 t2    -> ppType t1    <> text " \\subseteq " <> ppType t2
  SC s sl     -> ppSesLab sl  <> text " \\sim"       <> ppSession s
  BC b bvar   -> ppBehav b    <> text " \\subseteq " <> ppBeta bvar
  RC r rho    -> ppReg r      <> text " \\sim"       <> ppRho rho
  DC s1 s2    -> ppSession s1 <> text " \\bowtie"    <> ppSession s2
  EVarC as is (Psi i) -> hcat (punctuate
                          (comma <> text " + " )
                          (map
                            (\(l_i, s_i) -> text "?_{Ac} "
                                            <> text (l_i ++ ".")
                                            <> ppSession s_i ) (Map.assocs as)
                           ++
                           map
                            (\(l_i, s_i) -> text "?_{In} "
                                            <> text (l_i ++ ".")
                                            <> ppSession s_i ) (Map.assocs is)
                          ))
              <> text " \\sim \\psiext_{" <> ppUnique i <> text "}"

  IVarC cs (Psi i) -> hcat (punctuate
                          (comma <> text " (+) " )
                          (map
                            (\(l_i, s_i) -> text "!"
                                            <> text (l_i ++ ".")
                                            <> ppSession s_i ) (Map.assocs cs)))
              <> text " \\sim \\psiint_{" <> ppUnique i <> text "}"

instance Show Constraints where show = render . ppConstraints
ppConstraints :: Constraints -> Doc
ppConstraints cs = text "\\begin{itemize}\n\\item $ "
  <> hcat (punctuate (text " $\n\\item $ ") (map ppConstraint $ Set.toList cs))
  <> text " $\n\\end{itemize}"



showTC :: TypingContext -> String
showTC = render . ppTypingContext

instance Show TypingContext where show = showTC
ppTypingContext :: TypingContext -> Doc
ppTypingContext ctx = hcat (punctuate (text ", ") (map ppTCItem ctx) )

instance Show TCItem where show = render . ppTCItem
ppTCItem :: TCItem -> Doc
ppTCItem (TSVar x ts) = text (x ++ ":") <> ppTS ts
ppTCItem (TyVar x t ) = text (x ++ ":") <> ppType t

-------------------------------------------
-- Monotonicity
-------------------------------------------

class Monotonic a where
  isMonotonic     :: Unique -> a -> Bool
  isAntiMonotonic :: Unique -> a -> Bool



instance Monotonic Type where
  isMonotonic i t = case t of
    TV _  -> True
    TUnit -> True
    TBool -> True
    TInt  -> True
    TPair t1 t2   -> isMonotonic i t1 && isMonotonic i  t2
--    TFun  t1 t2   -> isAntiMonotonic i t1 && isMonotonic i t2
    TBFun t1 t2 _ -> isAntiMonotonic i t1 && isMonotonic i t2
--    TChan _ -> True -- TODO: not sure what this should be
    TSes _  -> True -- TODO: not sure what this should be

  isAntiMonotonic  i t = case t of
    TV (Alpha j) -> i /= j
    TUnit -> True
    TBool -> True
    TInt  -> True
    TPair t1 t2   -> isAntiMonotonic i t1 && isAntiMonotonic i  t2
--    TFun  t1 t2   -> isMonotonic i t1 && isAntiMonotonic i t2
    TBFun t1 t2 (Beta j) -> i /= j && isMonotonic i t1 && isAntiMonotonic i t2
--    TChan (SL _) -> True -- i /= j -- TODO: not sure what this should be
    TSes  rho       -> isAntiMonotonic i rho -- TODO: not sure what this should be


instance Monotonic Ses where
  isMonotonic i s = case s of
    SV   _  -> True
    EVar _  -> True
    IVar _  -> True
    SEnd    -> True
    --
    SSend t s' -> isAntiMonotonic i t && isMonotonic i s'
    SRecv t s' -> isMonotonic i t && isMonotonic i s'
    --
    SDeleg  s1 s2 -> isAntiMonotonic i s1 && isMonotonic i s2
    SResume s1 s2 -> isMonotonic i s1 && isMonotonic i s2
    --
    SInC ss -> all ( isMonotonic i . snd ) ss
    SExC as is -> all ( isMonotonic i . snd ) (as ++ is)


  isAntiMonotonic i s = case s of
    SV (Psi j)    -> i /= j
    EVar _ -> True      --TODO not sure about this
    IVar _ -> True      --TODO not sure about this
    SEnd          -> True
    --
    SSend t s1 -> isMonotonic i t && isAntiMonotonic i s1
    SRecv t s1 -> isAntiMonotonic i t && isAntiMonotonic i s1
    --
    SDeleg  s1 s2 -> isMonotonic i s1 && isAntiMonotonic i s2
    SResume s1 s2 -> isAntiMonotonic i s1 && isAntiMonotonic i s2
    --
    SInC ss -> all ( isAntiMonotonic i . snd ) ss
    SExC as is -> all ( isAntiMonotonic i . snd ) (as ++ is)

instance Monotonic Behav where
  isMonotonic i b = case b of
    BV _ -> True
    BTau -> True
    BSeq b1 b2 -> fb b1 && fb b2
    BPush _ s   -> fs s
    BOp  pa    -> case pa of
      BSend   r t   -> frho r && ft t
      BRecv   r t   -> frho r && ft t
      BDeleg  r1 r2 -> frho r1 && frho r2
      BResume r1 r2 -> frho r1 && frho r2
      BInC    r _   -> frho r
    BRec   b' _   -> fb b'
    BSpawn b'    -> fb b'
    BIn  b1 b2 -> fb b1 && fb b2
    BEx  r bs  -> frho r  && all (fb . snd) bs
   where fb = isMonotonic i
--         fr = isMonotonic i
         frho = isMonotonic i
         fs = isMonotonic i
         ft = isMonotonic i


  isAntiMonotonic i b = case b of
    BV (Beta j) -> i /= j
    BTau -> True
    BSeq b1 b2 -> fb b1 && fb b2
    BPush _ s   -> fs s
    BOp  pa    -> case pa of
      BSend   r t   -> frho r && ft t
      BRecv   r t   -> frho r && ft t
      BDeleg  r1 r2 -> frho r1 && frho r2
      BResume r1 r2 -> frho r1 && frho r2
      BInC    r _   -> frho r
    BRec  b' _    -> fb b'
    BSpawn b'    -> fb b'
    BIn  b1 b2 -> fb b1 && fb b2
    BEx  r bs  -> frho r  && all (fb . snd) bs
   where fb = isAntiMonotonic i
--         fr = isAntiMonotonic i
         frho = isAntiMonotonic i
         fs = isAntiMonotonic i
         ft = isAntiMonotonic i


instance Monotonic Reg where
  isMonotonic i (RV r)  = isMonotonic i r
  isMonotonic _ (RL _)  = True

  isAntiMonotonic i (RV (Rho j))    = i /= j
  isAntiMonotonic _ (RL _)  = True

instance Monotonic Rho where
  isMonotonic _ _ = True

  isAntiMonotonic i (Rho j)    = i /= j

-- variables are omitted according to the definition of LHS and Figure 4.8
instance Monotonic Constraint where
  isMonotonic i c = case c of
    TC t1 _ -> isMonotonic i t1
    BC b1 _ -> isMonotonic i b1
    RC k1 _ -> isMonotonic i k1
    SC s1 _ -> isMonotonic i s1
    DC _ _ -> True -- TODO: double check

    EVarC as is _ -> all (isMonotonic i) (Map.elems as ++ Map.elems is)
    IVarC cs _ -> all (isMonotonic i) (Map.elems cs)

  isAntiMonotonic i c = case c of
    TC t1 _ -> isAntiMonotonic i t1
    BC b1 _ -> isAntiMonotonic i b1
    RC k1 _ -> isAntiMonotonic i k1
    SC s1 _ -> isAntiMonotonic i s1
    DC _ _  -> True -- TODO: double check
    EVarC as is _ -> all (isAntiMonotonic i) (Map.elems as ++ Map.elems is)
    IVarC cs _ -> all (isAntiMonotonic i) (Map.elems cs)

instance Monotonic Constraints where
  isMonotonic i cs     = all (isMonotonic i)      ( Set.toList cs )
  isAntiMonotonic i cs = all (isAntiMonotonic i)  ( Set.toList cs )
